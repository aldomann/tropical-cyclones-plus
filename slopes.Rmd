---
title: "Bootstrap y permutation tests"
author: "Alfredo Hernández"
output:
  pdf_document: 
    fig_height: 3.5
    toc: yes
    toc_depth: 2
  html_document:
    df_print: paged
  html_notebook: default
---

```{r message=FALSE, warning=FALSE, include=FALSE}
# Libraries ------------------------------------------------
library(measurements) # Convert units

# Source base code -----------------------------------------
source("slopes_base.R")
load("slopes_analysis.RData")
```

\newpage
# Scatterplots

A continuación tenemos los scatterplots de $y(x)$ y $x(y)$ para el $PDI$, $\max{v}$, $\langle v \rangle$, y $\langle v^{2} \rangle$ comparados siempre con la duración del huracán.

## All storms
Veamos primero los plots para todas los huracanes (sin aplicar ningún filtro).

### North Atlantic (NATL)
```{r}
# NATL
plot_scatterplot("NATL", "storm.duration", "storm.pdi")
plot_scatterplot("NATL", "storm.duration", "max.wind")
plot_scatterplot("NATL", "storm.duration", "mean.wind")
plot_scatterplot("NATL", "storm.duration", "mean.sq.wind")
```

### East Pacific (EPAC)
```{r}
# EPAC
plot_scatterplot("EPAC", "storm.duration", "storm.pdi")
plot_scatterplot("EPAC", "storm.duration", "max.wind")
plot_scatterplot("EPAC", "storm.duration", "mean.wind")
plot_scatterplot("EPAC", "storm.duration", "mean.sq.wind")
```

## Developing systems
Ahora vemos los plots de los huracanes ignorando las tormentas pequeñas.

### North Atlantic (NATL)
```{r}
# NATL
plot_scatterplot("NATL", "storm.duration", "storm.pdi", 33)
plot_scatterplot("NATL", "storm.duration", "max.wind", 33)
plot_scatterplot("NATL", "storm.duration", "mean.wind", 33)
plot_scatterplot("NATL", "storm.duration", "mean.sq.wind", 33)
```

### East Pacific (EPAC)
```{r}
# EPAC
plot_scatterplot("EPAC", "storm.duration", "storm.pdi", 33)
plot_scatterplot("EPAC", "storm.duration", "max.wind", 33)
plot_scatterplot("EPAC", "storm.duration", "mean.wind", 33)
plot_scatterplot("EPAC", "storm.duration", "mean.sq.wind", 33)
```

\newpage
# Confidence intervals

Aquí hacemos bootstrap y utilizamos el método de bootstrap-t para tener una mejor estimación del valor del slope $\hat{b}$, su desviación estándard $\hat{se}(\hat{b})$, y el coeficiente de correlación $r^2$.

## Bootstrap (de las slides de Pere Puig)
Assume that we have consistent estimates of $b_{0}$ and its standard error at hand and that the asymptotic distribution of the t-statistic is the standard normal:
$$
	t = \frac{\hat{b} - b_{0}}{\hat{se}(\hat{b})} \to N(0,1)
$$

Draw $N$ independent bootstrap samples of size $n$ from the original sample. Estimate the t-value for each sample:
$$
	t_{n}^{\star} = \frac{\hat{b}_{n}^{\star} - \hat{b}}{\hat{se}_{n}^{\star}(\hat{b})} \quad for \quad n = 1, \dots , N
$$
where $\hat{b}_{n}^{\star}$ and $\hat{se}_{n}^{\star}(\hat{b})$ are estimates of the parameter $b$ and its standard error using the bootstrap sample.

Calculate $t_{\alpha/2}$ and $t_{1-\alpha/2}$ by means of the quantiles of $t_{n}^{\star}$. Finally,
the CI is constructed as follows,
$$
	[ \hat{b} + t_{\alpha/2} \cdot \hat{se}(\hat{b}), \hat{b} + t_{1-\alpha/2} \cdot \hat{se}(\hat{b}) ]
$$

## Resultados
```{r}
# NATL (all storms)
ci.list[lapply(purrr::map(ci.list, ~dplyr::filter(.x, basin == "NATL", min.speed == 0)), nrow) > 0]

# EPAC (all storms)
ci.list[lapply(purrr::map(ci.list, ~dplyr::filter(.x, basin == "EPAC", min.speed == 0)), nrow) > 0]
```

```{r}

# NATL (developing systems)
ci.list[lapply(purrr::map(ci.list, ~dplyr::filter(.x, basin == "NATL", min.speed == 33)), nrow) > 0]

# EPAC (developing systems)
ci.list[lapply(purrr::map(ci.list, ~dplyr::filter(.x, basin == "EPAC", min.speed == 33)), nrow) > 0]
```

\newpage
# Permutation tests

Aquí hacemos un permutation test con la hipótesis 
$$  
\begin{cases}
  H_{0} : b_{h} = b_{l} \\
  H_{1} : b_{h} \neq b_{l}
\end{cases} 
$$

Para comprovar esto utilizamos el estadístico 
$$
T = \frac{|b_{h} - b_{l}|}{\hat{se}_{b_{h} - b_{l}}}, \quad \text{donde} \quad \hat{se}_{b_{h} - b_{l}} = \sqrt{\hat{se}_{b_{h}}^{2} + \hat{se}_{b_{l}}^{2}}
$$

## El test (de las slides de Pere Puig)

1. Define your null hypothesis and the alternative.
2. Consider a statistic which is large (small) if your null hypothesis is not true, and small (large) if it is true.
3. Create a new data set consisting of your data, randomly rearranged. Exactly how it is rearranged depends on your null hypothesis.
4. Calculate your statistic for this new data set and compare it to your true value.
5. Repeat steps 3 and 4 many times (preferably several hundred).
6. If your true statistic is greater (lower) than 95% of the random values, then you can reject the null hypothesis at $p<0.05$.

El error asociado al $p$-value viene dado por 
$$ 1.96 \sqrt{\frac{p.value - (p.value)^2}{ n.sim}} $$
donde `n.sim` es el número de simulaciones en el test de permutación (5000 en nuestro caso).


## Resultados
Lo primero que comprovamos es que ningún $p$-value sea inferior a $\alpha = 0.05$:
```{r}
alpha = 0.05

# Print regressions with p-value <= alpha
for (i in 1:length(p.values.list)) {
	for (j in 1:2) {
		if (p.values.list[[i]][["p.value"]][1] <= alpha) {
			print(p.values.list[[i]][j,])
		}
	}
}
```
El output nulo, dado que todos los $p$-values son mayores que $\alpha$. Aún así, podemos ver los $p$-values de cada uno de los tests:

```{r}
# NATL (all storms)
p.values.list[lapply(purrr::map(p.values.list, ~filter(.x, basin == "NATL", min.speed == 0)), nrow) > 0]

# NATL (all storms)
p.values.list[lapply(purrr::map(p.values.list, ~filter(.x, basin == "EPAC", min.speed == 0)), nrow) > 0]

# NATL (developing systems)
p.values.list[lapply(purrr::map(p.values.list, ~filter(.x, basin == "NATL", min.speed == 33)), nrow) > 0]

# EPAC (developing systems)
p.values.list[lapply(purrr::map(p.values.list, ~filter(.x, basin == "EPAC", min.speed == 33)), nrow) > 0]
```

Lo que podemos ver es que no se rechaza la hipótesis nula $H_{0}$ en ningún caso (quizá el más delicado es el caso de `storm.pdi ~ storm.duration` para el EPAC filtrando tormentas pequeñas). 
